#################
# Rust Snippets #
#################

# Functions
# Function definition
snippet fn
	fn ${1:function_name}(${2})${3} {
		${0}
	}
# Function definition
snippet pfn
	pub fn ${1:function_name}(${2})${3} {
		${0}
	}
# Unit test function
snippet test
	#[test]
	fn ${1:test_function_name}() {
		${0}
	}
# Bench function
snippet bench
	#[bench]
	fn ${1:bench_function_name}(b: &mut test::Bencher) {
		b.iter(|| {
			${0}
		})
	}
# Constructor function
snippet new
	pub fn new(${1}) -> ${2:Name} {
		${2} { ${3} }
	}
# Main function
snippet main
	pub fn main() {
		${0}
	}
# let variable declaration with type inference
snippet let
	let ${1}  = ${2};
# let variable declaration with explicit type annotation
snippet lett
	let ${1}: ${2}  = ${3};
# let mut variable declaration with type inference
snippet letm
	let mut ${1}  = ${2};
# let mut variable declaration with explicit type annotation
snippet lettm
	let mut ${1}: ${2}  = ${3};
# println!
snippet pln
	println!("${1}");
# println! with format param
snippet pln,
	println!("${1}", ${2});
# Modules
# extern crate
snippet ec
	extern crate ${1:sync};
# extern crate log
snippet ecl
	#[macro_use]
	extern crate log;
snippet mod
	mod ${1:Filename} {
		${0}
	} /* ${1} */
# Test module
snippet testmod
	#[cfg(test)]
	mod tests {
		use super::${1:*};

		test${0}
	}
# Attributes
# allow lint attribute
snippet allow
	#[allow(${1:unused_variable})]
# cfg attribute
snippet cfg
	#[cfg(${1:target_os = "linux"})]
# feature attribute
snippet feat
	#![feature(${1:plugin})]
# #[derive(..)]
snippet der
	#[derive(${1:Debug})]
#  #[..]
snippet attr
	#[${1:inline}]
# Define create meta attributes
snippet crate
	// Crate name
	#![crate_name = "${1:crate_name}"]
	// Additional metadata attributes
	#![desc = "${2:Descrption.}"]
	#![license = "${3:BSD}"]
	#![comment = "${4:Comment.}"]
	// Specify the output type
	#![crate_type = "${5:lib}"]
# Common types
# Option<T>
snippet opt
	Option<${1:i32}>
# Result<T, E>
snippet res
	Result<${1:~str}, ${2:()}>
# Control structures
snippet if
	if ${1} {
		${0}
	}
# if / else
snippet ife
	if ${1} {
		${2}
	} else {
		${0}
	}
# if let expression
snippet ifl
	if let ${1} = ${2} {
		${0}
	}
# else
snippet el
	else {
		${0}
	}
# else if
snippet eli
	else if ${1} {
		${0}
	}
# match pattern
snippet mat
	match ${1} {
		${2} => ${3}
	}
# Case clause of pattern match
snippet case
	${1:_} => ${2:expression}
# loop {}
snippet loop
	loop {
		${0}
	}
# while loop
snippet wh
	while ${1:condition} {
		${0}
	}
# for ... in ... loop
snippet for
	for ${1:i} in ${2} {
		${0}
	}
# TODO commenting
# TODO comment
snippet todo
	// [TODO]: ${0:Description}
# FIXME comment
snippet fixme
	// FIXME: ${0}
# Struct
# Struct definition
snippet st
	struct ${1:name} {
		${0}
	}
# Struct/Trait implementation
snippet impl
	impl ${1:Type/Trait}${2:} for ${3:Type} {
		${0}
	}
# Struct with new constructor
snippet stn
	pub struct ${1:name} {
		${0}
	}

	impl ${1} {
		pub fn new(${2}) -> ${1} {
			${1} { ${3} }
		}
	}
# Type alias
snippet type
	type ${1:NewName} = ${2};
# enum definition
snippet enum
	enum ${1:Name} {
		${2},
	}
# Traits
# Trait definition
snippet trait
	trait ${1:Name} {
		${0}
	}
# Drop trait implementation (destructor)
snippet drop
	impl Drop for ${1:Name} {
		fn drop(&mut self) {
			${0}
		}
	}
# Statics
# static string declaration
snippet ss
	static ${1}: &'static str = "${0}";
# static item declaration
snippet stat
	static ${1}: ${2:usize} = ${0};
# Concurrency
# spawn a scoped thread
snippet scoped
	thread::scoped(${1:move }|| {
		${0}
	});
# spawn a thread
snippet spawn
	thread::spawn(${1:move }|| {
		${0}
	});
# Declare (Sender, Receiver) pair of asynchronous channel()
snippet chan
	let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();
# Testing
# assert!
snippet as
	assert!(${1:predicate})
# assert_eq!
snippet ase
	assert_eq!(${1:expected}, ${2:actual})
